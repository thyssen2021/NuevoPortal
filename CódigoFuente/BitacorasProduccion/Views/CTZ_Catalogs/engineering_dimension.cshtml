@model IEnumerable<Portal_2_0.Models.CTZ_Projects>
@{
    ViewBag.Title = "Min-Max Dimensions per Line";
    ViewBag.PrimerNivel = "cotizador";
    ViewBag.SegundoNivel = "ctz_catalogs";
    ViewBag.ControllerName = ViewContext.RouteData.Values["controller"];
    ViewBag.nav_style = "nav-sm";
}

@section estilos
{
    <link href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css" rel="stylesheet" />
    <!-- SweetAlert2 -->
    <link href="@Url.Content("~/Content/vendors/sweetalert2-theme-bootstrap-4/bootstrap-4.min.css")" rel="stylesheet">
    <!-- Select2 -->
    <link href="@Url.Content("~/Content/vendors/select2/css/select2.css")" rel="stylesheet">
    <link href="@Url.Content("~/Content/vendors/select2-bootstrap4-theme/select2-bootstrap4.min.css")" rel="stylesheet">
    <!--Handsontable -->
    <link href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" rel="stylesheet">
    <style>
        /* Nuevos Estilos */
        .ht_clone_top th {
            background-color: #009ff5; /* color corporativo de ejemplo */
            color: #ffffff;
        }

        .select2-container {
            min-width: 200px;
        }

        /*Para color de celdas readonly*/
        .handsontable .htDimmed {
            background: #f2f1f1;
        }


        .section-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #009ff5;
            margin-top: 20px;
            margin-bottom: 15px;
            border-bottom: 2px solid #009ff5;
            padding-bottom: 5px;
        }
    </style>
}

<div class="right_col" role="main">
    <div class="">
        <div class="clearfix"></div>
        <div class="row">
            <div class="col-md-12 col-sm-12">
                <div class="x_panel">

                    <div class="x_content">
                        <!-- Inicio Contenido -->
                        <div class="section-title">Min-Max Dimensions per Line</div>

                        <div class="row">
                            <div class="col-sm-3">
                                <label for="ddlPlant">Plant:</label>
                                <select id="ddlPlant" class="form-control">
                                    <option value="">-- Select Plant --</option>
                                    @if (ViewBag.Plants != null)
                                    {
                                        foreach (var item in (SelectList)ViewBag.Plants)
                                        {
                                            <option value="@item.Value">@item.Text</option>
                                        }
                                    }
                                </select>
                            </div>

                            <div class="col-sm-3">
                                <label for="ddlLine">Line:</label>
                                <select id="ddlLine" class="form-control">
                                    <option value="">-- Select Line --</option>
                                </select>
                            </div>
                        </div>

                        <br />


                        <!-- Handsontable se ubicará aquí -->
                        <div id="hotTable" style="overflow:auto;"></div>

                        <hr />

                        <div class="row">
                            <div class="col-sm-6 text-right">

                                @* Botón SAVE, inicialmente oculto *@
                                <button id="btnSaveData" class="btn btn-success" style="display:none;">
                                    <i class="fa fa-save"></i> Save
                                </button>
                            </div>
                        </div>
                        <!-- Finaliza contenido Contenido -->

                        <hr />

                        <div class="section-title">Theoretical Line Selection Rules</div>
                        <div id="theoreticalRulesHot" style="overflow:auto; margin-top:10px;"></div>
                        <div class="text-right" style="margin-top: 10px;">
                            <button id="btnAddRule" class="btn btn-info">
                                <i class="fa fa-plus"></i> Add Rule
                            </button>
                            <button id="btnSaveRules" class="btn btn-primary">
                                <i class="fa fa-save"></i> Save Rules
                            </button>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <!-- SweetAlert2 -->
    @Scripts.Render(Url.Content("~/Content/vendors/sweetalert2/sweetalert2.min.js"))
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
    @Scripts.Render(Url.Content("~/Content/vendors/select2/js/select2.full.min.js"))
    <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>
    <script>
        $(document).ready(function () {
            // --- CONFIGURACIÓN GENERAL ---
            toastr.options = { "positionClass": "toast-top-right", "progressBar": true };
            $('#ddlPlant, #ddlLine').select2({ width: '100%' })

            // --- VARIABLES GLOBALES ---
            let plantsForDropdown = @Html.Raw(Json.Encode(ViewBag.PlantsForGrid)) || [];
            let materialTypesForDropdown = @Html.Raw(Json.Encode(ViewBag.MaterialTypesForGrid)) || [];
            let linesForDropdown = @Html.Raw(Json.Encode(ViewBag.AllLinesForGrid)) || [];
            let lineMaterialMap = @Html.Raw(Json.Encode(ViewBag.LineMaterialTypeMap)) || [];


            // --- LÓGICA PARA TABLA 1: ENGINEERING DIMENSIONS ---
            var hot;
            initializeDimHot();
            $('#ddlPlant').on('change', onPlantChange);
            $('#ddlLine').on('change', onLineChange);
            $('#btnSaveData').on('click', saveDimData);

            // --- LÓGICA PARA TABLA 2: THEORETICAL LINE RULES ---
            var theoreticalRulesHot = null; // Instancia de la tabla, inicia en null
            var theoreticalRulesData = [];  // Arreglo que contendrá los datos de las reglas

            loadTheoreticalRules(); // Carga inicial de las reglas

            $('#btnAddRule').on('click', addRule);
            $('#btnSaveRules').on('click', saveRules);


            // ===================================================================
            // FUNCIONES PARA TABLA 1: ENGINEERING DIMENSIONS (Sin cambios)
            // ===================================================================
            function initializeDimHot() {
                var container = document.getElementById('hotTable');
                hot = new Handsontable(container, {
                    data: [],
                    columns: [
                        { data: 'ID_Engineering_Dimension', type: 'numeric', readOnly: true },
                        { data: 'Plant', type: 'text', readOnly: true },
                        { data: 'Line', type: 'text', readOnly: true },
                        { data: 'Criteria', type: 'text', readOnly: true },
                        { data: 'MinValue', type: 'numeric', numericFormat: { pattern: '0,0.000' } },
                        { data: 'MaxValue', type: 'numeric', numericFormat: { pattern: '0,0.000' } }
                    ],
                    colHeaders: ['ID', 'Plant', 'Line', 'Criteria', 'Min Value', 'Max Value'],
                    rowHeaders: true, filters: true, dropdownMenu: true, width: '100%',
                    height: 250, autoColumnSize: { useHeaders: true },
                    licenseKey: 'non-commercial-and-evaluation'
                });
            }
           function onPlantChange() {
                var plantId = $(this).val();
                hot.loadData([]);
                $('#btnSaveData').hide();
                if (!plantId) {
                    $('#ddlLine').html('<option value="">-- Select Line --</option>').trigger('change.select2');
                    return;
                }
                $.getJSON('@Url.Action("GetLinesByPlant", "CTZ_Catalogs")', { plantId: plantId }, function (data) {
                    var items = '<option value="">-- Select Line --</option>';
                    $.each(data, function (i, item) { items += `<option value="${item.ID_Line}">${item.Line_Name}</option>`; });
                    $('#ddlLine').html(items).trigger('change.select2');
                });
            }

            function onLineChange() {
                var plantId = $('#ddlPlant').val();
                var lineId = $(this).val();
                if (!plantId || !lineId) {
                    hot.loadData([]);
                    $('#btnSaveData').hide();
                    return;
                }
                $.getJSON('@Url.Action("LoadEngineeringDimension", "CTZ_Catalogs")', { plantId: plantId, lineId: lineId }, function (response) {
                    hot.loadData(response || []);
                    $('#btnSaveData').toggle(response && response.length > 0);
                }).fail(function() {
                    Swal.fire('Error', 'An error occurred while loading dimensions.', 'error');
                });
            }

            function saveDimData() {
                var tableData = hot.getSourceData();
                $.ajax({
                    url: '@Url.Action("SaveEngineeringDimension", "CTZ_Catalogs")',
                    type: 'POST',
                    contentType: 'application/json; charset=utf-8',
                    data: JSON.stringify(tableData),
                    success: function (res) {
                        Swal.fire(res.success ? 'Success' : 'Error', res.message, res.success ? 'success' : 'error');
                    },
                    error: function () { Swal.fire('Error', 'An error occurred while saving dimensions.', 'error'); }
                });
            }


            // ===================================================================
            // FUNCIONES PARA TABLA 2: THEORETICAL LINE RULES (Código corregido)
            // ===================================================================

            /**
             * Esta es la función clave. Destruye la tabla si existe y la crea de nuevo.
             * Esto garantiza un estado limpio siempre.
             */
            function renderRulesTable() {
                if (theoreticalRulesHot) {
                    theoreticalRulesHot.destroy();
                }
                var container = document.getElementById('theoreticalRulesHot');

                // Función renderizadora genérica para nuestras columnas de dropdown    
                // Reemplaza tu función dropdownRenderer actual por esta versión final
                function dropdownRenderer(instance, td, row, col, prop, value, cellProperties) {
                    // 'value' es el ID que está guardado en los datos (ej. 4)

                    let sourceArray;
                    // 1. Identificamos qué lista de opciones usar para esta columna
                    if (prop === 'ID_Plant') {
                        sourceArray = plantsForDropdown;
                    } else if (prop === 'ID_Material_Type') {
                        sourceArray = materialTypesForDropdown;
                    } else if (prop === 'Resulting_Line_ID') {
                        sourceArray = linesForDropdown;
                    }

                    // 2. Buscamos el texto correspondiente al ID ('value')
                    let textToDisplay = ''; // Por defecto, si no hay valor, mostramos vacío
                    if (sourceArray && value !== null && value !== undefined) {
                        const selectedItem = sourceArray.find(item => item.Value == value);
                        if (selectedItem) {
                            textToDisplay = selectedItem.Text;
                        } else {
                            // Si por alguna razón el ID existe pero no está en la lista de opciones
                            // (p.ej. después de un filtro en cascada), mostramos el ID para no perder el dato.
                            textToDisplay = value;
                        }
                    }

                    // 3. Llamamos al renderizador de texto original de Handsontable,
                    //    pero le pasamos nuestro texto encontrado en lugar del ID.
                    Handsontable.renderers.TextRenderer.apply(this, [instance, td, row, col, prop, textToDisplay, cellProperties]);

                    // 4. Añadimos manualmente la flecha del dropdown a la celda.
                    //    La clase 'htAutocompleteArrow' es de Handsontable y le da el estilo correcto.
                    td.innerHTML += '<div class="htAutocompleteArrow">▼</div>';
                }

                theoreticalRulesHot = new Handsontable(container, {
                    data: theoreticalRulesData,
                    rowHeaders: true,
                    colHeaders: ['Del', 'ID', 'Description', 'Plant', 'Material Type', 'Min Thick', 'Max Thick', 'Min Width', 'Max Width', 'Min Pitch', 'Max Pitch', 'Min Tensile', 'Max Tensile', 'Special Rule Key', 'Resulting Line', 'Priority', 'Active'],
                    columns: [
                        { renderer: 'html', readOnly: true, width: 40 },
                        { data: 'ID_Rule', readOnly: true },
                        { data: 'Description', type: 'text' },
                        {
                            data: 'ID_Plant',
                            type: 'dropdown', // <-- CAMBIO 1: De 'editor' a 'type'
                            source: plantsForDropdown.map(p => p.Text), // <-- CAMBIO 2: De 'selectOptions' a 'source'
                            renderer: dropdownRenderer,
                            validator: function (value, callback) { callback(value != null && value !== ''); }
                        },
                        {
                            data: 'ID_Material_Type',
                            type: 'dropdown', // <-- CAMBIO 1
                            source: materialTypesForDropdown.map(m => m.Text), // <-- CAMBIO 2
                            renderer: dropdownRenderer,
                            validator: function (value, callback) { callback(value != null && value !== ''); }
                        },
                        {
                            data: 'Thickness_Min', type: 'numeric', numericFormat: { pattern: '0,0.00' },
                            validator: function (value, callback) {
                                //valida vacios
                                if (value === null || value === '') {
                                    callback(true);
                                } else {
                                    // Si hay un valor, verificamos si es un número válido.
                                    // isNaN() devuelve true si NO es un número.
                                    callback(!isNaN(value));
                                }
                            }
                        },
                        {
                            data: 'Thickness_Max', type: 'numeric', numericFormat: { pattern: '0,0.00' },
                            validator: function (value, callback) {
                                //valida vacios
                                if (value === null || value === '') {
                                    callback(true);
                                } else {
                                    // Si hay un valor, verificamos si es un número válido.
                                    // isNaN() devuelve true si NO es un número.
                                    callback(!isNaN(value));
                                }
                            }
                        },
                        {
                            data: 'Width_Min', type: 'numeric', numericFormat: { pattern: '0,0.00' },
                            validator: function (value, callback) {
                                //valida vacios
                                if (value === null || value === '') {
                                    callback(true);
                                } else {
                                    // Si hay un valor, verificamos si es un número válido.
                                    // isNaN() devuelve true si NO es un número.
                                    callback(!isNaN(value));
                                }
                            }
                        },
                        {
                            data: 'Width_Max', type: 'numeric', numericFormat: { pattern: '0,0.00' },
                            validator: function (value, callback) {
                                //valida vacios
                                if (value === null || value === '') {
                                    callback(true);
                                } else {
                                    // Si hay un valor, verificamos si es un número válido.
                                    // isNaN() devuelve true si NO es un número.
                                    callback(!isNaN(value));
                                }
                            }
                        },
                        {
                            data: 'Pitch_Min', type: 'numeric', numericFormat: { pattern: '0,0.00' },
                            validator: function (value, callback) {
                                //valida vacios
                                if (value === null || value === '') {
                                    callback(true);
                                } else {
                                    // Si hay un valor, verificamos si es un número válido.
                                    // isNaN() devuelve true si NO es un número.
                                    callback(!isNaN(value));
                                }
                            }
                        },
                        {
                            data: 'Pitch_Max', type: 'numeric', numericFormat: { pattern: '0,0.00' },
                            validator: function (value, callback) {
                                //valida vacios
                                if (value === null || value === '') {
                                    callback(true);
                                } else {
                                    // Si hay un valor, verificamos si es un número válido.
                                    // isNaN() devuelve true si NO es un número.
                                    callback(!isNaN(value));
                                }
                            }
                        },
                        {
                            data: 'Tensile_Min', type: 'numeric', numericFormat: { pattern: '0,0.00' },
                            validator: function (value, callback) {
                                //valida vacios
                                if (value === null || value === '') {
                                    callback(true);
                                } else {
                                    // Si hay un valor, verificamos si es un número válido.
                                    // isNaN() devuelve true si NO es un número.
                                    callback(!isNaN(value));
                                }
                            }
                        },
                        {
                            data: 'Tensile_Max', type: 'numeric', numericFormat: { pattern: '0,0.00' },
                            validator: function (value, callback) {
                                //valida vacios
                                if (value === null || value === '') {
                                    callback(true);
                                } else {
                                    // Si hay un valor, verificamos si es un número válido.
                                    // isNaN() devuelve true si NO es un número.
                                    callback(!isNaN(value));
                                }
                            }
                        },
                        { data: 'Special_Rule_Key', type: 'text' },
                        {
                            data: 'Resulting_Line_ID',
                            type: 'dropdown', // <-- CAMBIO 1
                            source: linesForDropdown.map(l => l.Text), // <-- CAMBIO 2
                            renderer: dropdownRenderer,
                            validator: function (value, callback) { callback(value != null && value !== ''); }
                        },
                        {
                            data: 'Priority', type: 'numeric',
                            validator: function (value, callback) {
                                //valida vacios
                                if ((value == null || value == '')) {
                                    callback(false);
                                }
                                else {
                                    callback(true);
                                }
                            }
                        },
                        { data: 'Is_Active', type: 'checkbox', className: 'htCenter' }
                    ],
                    width: '100%',
                    height: 500,
                    stretchH: 'all',
                    filters: true,
                    dropdownMenu: true,
                    licenseKey: 'non-commercial-and-evaluation',
                    beforeChange: function (changes) {
                        changes.forEach(function (change) {
                            let prop = change[1];
                            let newValue = change[3];
                            // Esta lógica ahora solo se preocupa de convertir Texto -> ID al editar.
                            if (prop === 'ID_Plant') {
                                let plant = plantsForDropdown.find(p => p.Text === newValue);
                                if (plant) change[3] = plant.Value;
                            } else if (prop === 'ID_Material_Type') {
                                let type = materialTypesForDropdown.find(t => t.Text === newValue);
                                if (type) change[3] = type.Value;
                            } else if (prop === 'Resulting_Line_ID') {
                                let line = linesForDropdown.find(l => l.Text === newValue);
                                if (line) change[3] = line.Value;
                            }
                        });
                    },
                    afterChange: function (changes, source) {
                        if (source !== 'edit') {
                            return;
                        }

                        changes.forEach(change => {
                            const [row, prop, oldValue, newValue] = change;

                            if (prop === 'ID_Plant') {
                                const selectedPlantId = newValue;
                                const plantExists = plantsForDropdown.some(p => p.Value == selectedPlantId);
                                if (!plantExists) return;

                                // --- 1. Filtrar "Resulting Line" ---
                                const filteredLines = linesForDropdown
                                    .filter(line => line.PlantId == selectedPlantId)
                                    .map(line => line.Text);

                                const resultingLineCell = this.getCellMeta(row, this.propToCol('Resulting_Line_ID'));

                                // ===== LÍNEA MODIFICADA =====
                                resultingLineCell.source = filteredLines;

                                const currentLineId = this.getDataAtRowProp(row, 'Resulting_Line_ID');
                                const currentLine = linesForDropdown.find(l => l.Value == currentLineId);
                                if (currentLine && currentLine.PlantId != selectedPlantId) {
                                    this.setDataAtRowProp(row, 'Resulting_Line_ID', null, 'cascade');
                                }

                                // --- 2. Filtrar "Material Type" ---
                                const lineIdsForPlant = linesForDropdown
                                    .filter(line => line.PlantId == selectedPlantId)
                                    .map(line => line.Value);

                                const materialTypeIdsForPlant = lineMaterialMap
                                    .filter(map => lineIdsForPlant.includes(map.ID_Line))
                                    .map(map => map.ID_Material_Type);

                                const uniqueMaterialTypeIds = [...new Set(materialTypeIdsForPlant)];

                                const filteredMaterialTypeOptions = materialTypesForDropdown
                                    .filter(mt => uniqueMaterialTypeIds.includes(mt.Value))
                                    .map(mt => mt.Text);

                                const materialTypeCell = this.getCellMeta(row, this.propToCol('ID_Material_Type'));

                                // ===== LÍNEA MODIFICADA =====
                                materialTypeCell.source = filteredMaterialTypeOptions;

                                this.setDataAtRowProp(row, 'ID_Material_Type', null, 'cascade');
                            }
                        });
                    },
                    afterGetColHeader: function (col, TH) {
                        if (col === 0) { TH.innerHTML = '<i class="fa-solid fa-trash"></i>'; }
                    },
                    cells: function (row, col) {
                        var cellProperties = {};
                        if (col === 0) {
                            cellProperties.renderer = function (instance, td) {
                                td.innerHTML = `<button class="btn btn-danger btn-xs" onclick="deleteRuleRow(${row})"><i class="fa-solid fa-trash"></i></button>`;
                            };
                        }
                        return cellProperties;
                    }
                });
            }

            window.deleteRuleRow = function (rowIndex) {
                Swal.fire({
                    title: 'Are you sure?',
                    text: "This rule will be removed. Changes will be permanent after saving.",
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#d33',
                    confirmButtonText: 'Yes, remove it!'
                }).then((result) => {
                    if (result.isConfirmed) {
                        theoreticalRulesData.splice(rowIndex, 1);
                        renderRulesTable(); // Recarga y renderiza la tabla con el nuevo arreglo
                        toastr.info('Rule removed from grid. Click "Save Rules" to apply changes.');
                    }
                });
            };

          function loadTheoreticalRules() {
                $.getJSON('@Url.Action("GetTheoreticalRules", "CTZ_Catalogs")', function (data) {
                    // Ya no necesitamos el bucle forEach para convertir ID a Texto aquí.
                    // Simplemente guardamos los datos crudos (con IDs)
                    theoreticalRulesData = data;
                    renderRulesTable();
                }).fail(function () {
                    Swal.fire('Error', 'Could not load the theoretical line selection rules.', 'error');
                });
            }

            function addRule() {
                theoreticalRulesData.push({ Is_Active: true, Priority: 100 });
                renderRulesTable();
                theoreticalRulesHot.selectCell(theoreticalRulesData.length - 1, 1); // Selecciona la nueva fila
            }

           // En la sección <script> de Engineering_Dimension.cshtml

            function saveRules() {

                theoreticalRulesHot.validateCells((valid) => {
                    if (valid) {
                    }
                });

            let dataToSave = theoreticalRulesHot.getSourceData();

            // --- INICIO DE LA VALIDACIÓN ---
            let validationErrors = [];
            let requiredFields = ['ID_Plant', 'ID_Material_Type', 'Resulting_Line_ID', 'Priority'];

            dataToSave.forEach(function (row, rowIndex) {
                // Ignorar filas completamente vacías que a veces Handsontable puede generar
                if (Object.values(row).every(val => val === null || val === '')) {
                    return; // Es una fila vacía, la saltamos
                }

                let missingFieldsInRow = [];
                requiredFields.forEach(function (field) {
                    // Un campo está "vacío" si es null, undefined o una cadena vacía
                    if (row[field] === null || row[field] === undefined || row[field] === '') {
                        // Buscamos el "nombre amigable" de la columna para el mensaje de error
                        let colIndex = theoreticalRulesHot.propToCol(field);
                        let colHeader = theoreticalRulesHot.getColHeader(colIndex);
                        missingFieldsInRow.push(colHeader);
                    }
                });

                if (missingFieldsInRow.length > 0) {
                    validationErrors.push(`Row ${rowIndex + 1} is missing required fields: ${missingFieldsInRow.join(', ')}.`);
                }
            });

            if (validationErrors.length > 0) {
                // Si hay errores, los mostramos todos juntos en un SweetAlert
                Swal.fire({
                    icon: 'error',
                    title: 'Validation Failed',
                    html: '<div style="text-align: left; max-height: 200px; overflow-y: auto;">' + validationErrors.join('<br>') + '</div>',
                    confirmButtonColor: '#009ff5'
                });
                return; // Detenemos la ejecución, no se guarda nada.
            }
            // --- FIN DE LA VALIDACIÓN ---


            // Si la validación pasa, continuamos con el proceso de guardado...

            // Convertir textos de dropdowns a IDs antes de enviar
            dataToSave.forEach(function (row) {
                if (isNaN(parseInt(row.ID_Plant))) {
                    let plant = plantsForDropdown.find(p => p.Text === row.ID_Plant);
                    if (plant) row.ID_Plant = parseInt(plant.Value);
                }
                if (isNaN(parseInt(row.ID_Material_Type))) {
                    let type = materialTypesForDropdown.find(t => t.Text === row.ID_Material_Type);
                    if (type) row.ID_Material_Type = parseInt(type.Value);
                }
                if (isNaN(parseInt(row.Resulting_Line_ID))) {
                    let line = linesForDropdown.find(l => l.Text === row.Resulting_Line_ID);
                    if (line) row.Resulting_Line_ID = parseInt(line.Value);
                }
            });

            $.ajax({
                url: '@Url.Action("SaveTheoreticalRules", "CTZ_Catalogs")',
                type: 'POST',
                contentType: 'application/json; charset=utf-8',
                data: JSON.stringify(dataToSave),
                success: function (res) {
                    if (res.success) {
                        Swal.fire('Success!', res.message, 'success').then(() => loadTheoreticalRules());
                    } else {
                        Swal.fire('Error', res.message, 'error');
                    }
                },
                error: function () {
                    Swal.fire('Error', 'An unexpected error occurred while saving the rules.', 'error');
                }
            });
        }
        });
    </script>
}
